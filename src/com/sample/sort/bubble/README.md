# Bubble Sort

- 인접한 두 개의 원소를 비교하영 자리를 교환하는 방식이다.
- 정수 10개를 정렬하는데 55회의 연산이 필요했다.

## 정렬 프로세스

1. 첫 번째 원소부터 마지막 원소까지 반복하여 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
2. 첫 번재 원소부터 인접한 원소끼리 계속 자리를 교환하면서, 맨 마지작 자리로 이동하는 모습이 물속에서 물 위로 올라오는 물방울 모양과 같다고 하여 버블(Bubble) 정렬이라고 한다.

## 버블 정렬 소스 코드
```java
  public static int[] sort(final int[] src) {
    // 원본 배열을 복사해서 새 배열을 생성한다.
    int[] arr = Arrays.copyOf(src, src.length);

    // 배열의 길이를 조회해서 변수에 저장한다.
    final int len = src.length;

    // 배열의 크기만큼 반복작업을 수행한다.
    for (int i = 0; i < len; i++) {
      // 배열의 0번째부터 (배열의 길이 - i)번째까지 반복한다.
      // 0 ~ 9, 0 ~ 8, 0 ~ 7, 0 ~ 6 .... 의 순서로 for문이 반복실행된다. 
      // for문이 한 번 실행될 때 마다  인접한 원소를 비교해서 자리를 교환한다.
      // for문의 실행이 완료되면 가장 큰 수가 (배열의 길이 - i)번째 칸에 위치하게 된다.
      for (int j = 0; j < len - i; j++) {
        // j + 1값이 배열의 길이보다 작고, j번째 값이 j + 1번째 값보다 크면 자리를 교환한다.
        if (j + 1 < len && arr[j] > arr[j + 1]) {
          int temp = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = temp;
        }
      }
    }

    return arr;
  }
```

## 정렬된 배열 예시

```java
[84, 27, 95, 11, 85, 5, 54, 97, 31, 49]
```

- 1번째 정렬 [27, 84, 11, 85, 5, 54, 95, 31, 49, **97**]
- 2번째 정렬 [27, 11, 84, 5, 54, 85, 31, 49, **95**, 97]
- 3번째 정렬 [11, 27, 5, 54, 84, 31, 49, **85**, 95, 97]
- 4번째 정렬 [11, 5, 27, 54, 31, 49, **84**, 85, 95, 97]
- 5번째 정렬 [5, 11, 27, 31, 49, **54**, 84, 85, 95, 97]
- 6번째 정렬 [5, 11, 27, 31, **49**, 54, 84, 85, 95, 97]
- 7번째 정렬 [5, 11, 27, **31**, 49, 54, 84, 85, 95, 97]
- 8번째 정렬 [5, 11, **27**, 31, 49, 54, 84, 85, 95, 97]
- 9번째 정렬 [5, **11**, 27, 31, 49, 54, 84, 85, 95, 97]
- 10번째 정렬 [**5**, 11, 27, 31, 49, 54, 84, 85, 95, 97]